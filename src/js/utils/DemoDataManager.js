/**
 * Demo Data Manager
 * Implements platform-generated demo data pattern
 * 
 * Key Principle: Demo data should be generated by the actual platform,
 * not separate scripts that will diverge and create their own bugs.
 */

import logger from './Logger.js';

class DemoDataManager {
  constructor(platformAPI, storageManager) {
    this.platformAPI = platformAPI;
    this.storageManager = storageManager;
    this.demoDataKey = 'demo_data';
    this.lastRefreshKey = 'demo_data_last_refresh';
    this.refreshInterval = 24 * 60 * 60 * 1000; // 24 hours
  }

  /**
   * Load demo data from platform
   * Always gets fresh data from platform, never uses synthetic generators
   */
  async loadDemoData() {
    try {
      logger.log('üìä Loading demo data from platform...');
      
      // Check if we have recent demo data
      const lastRefresh = this.storageManager.getData(this.lastRefreshKey);
      const now = Date.now();
      
      if (lastRefresh && (now - lastRefresh) < this.refreshInterval) {
        logger.log('üìä Using cached demo data');
        return this.storageManager.getData(this.demoDataKey);
      }
      
      // Get fresh demo data from platform
      const demoData = await this.fetchDemoDataFromPlatform();
      
      // Store in local storage
      this.storageManager.setData(this.demoDataKey, demoData);
      this.storageManager.setData(this.lastRefreshKey, now);
      
      logger.log('‚úÖ Demo data loaded successfully');
      return demoData;
      
    } catch (error) {
      logger.error('‚ùå Failed to load demo data:', error);
      
      // Try to use cached data as fallback
      const cachedData = this.storageManager.getData(this.demoDataKey);
      if (cachedData) {
        logger.log('üìä Using cached demo data as fallback');
        return cachedData;
      }
      
      throw new Error('Demo data unavailable - check platform connection');
    }
  }

  /**
   * Fetch demo data from platform API
   * This should use the actual platform's demo data generation
   */
  async fetchDemoDataFromPlatform() {
    if (!this.platformAPI) {
      throw new Error('Platform API not available');
    }

    // Use platform's demo data API
    const response = await fetch('/api/demo-data', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${this.getDemoToken()}`
      }
    });

    if (!response.ok) {
      throw new Error(`Platform API error: ${response.status} ${response.statusText}`);
    }

    const demoData = await response.json();
    
    // Validate demo data structure
    this.validateDemoData(demoData);
    
    return demoData;
  }

  /**
   * Get demo token for platform API
   * In production, this would be a proper authentication token
   */
  getDemoToken() {
    // In a real implementation, this would be a proper demo token
    // For now, return a placeholder
    return 'demo-token-placeholder';
  }

  /**
   * Validate demo data structure
   * Ensures demo data has expected structure
   */
  validateDemoData(demoData) {
    if (!demoData || typeof demoData !== 'object') {
      throw new Error('Invalid demo data: must be an object');
    }

    // Add validation for expected demo data structure
    // This should match what the platform generates
    const requiredFields = ['users', 'projects', 'tasks'];
    
    for (const field of requiredFields) {
      if (!demoData[field] || !Array.isArray(demoData[field])) {
        throw new Error(`Invalid demo data: missing or invalid ${field} field`);
      }
    }

    logger.log('‚úÖ Demo data validation passed');
  }

  /**
   * Refresh demo data from platform
   * Forces a fresh fetch from platform
   */
  async refreshDemoData() {
    logger.log('üîÑ Refreshing demo data from platform...');
    
    // Clear cached data
    this.storageManager.removeData(this.lastRefreshKey);
    
    // Load fresh data
    return await this.loadDemoData();
  }

  /**
   * Check if demo data is available
   */
  isDemoDataAvailable() {
    return this.storageManager.getData(this.demoDataKey) !== null;
  }

  /**
   * Get demo data age in hours
   */
  getDemoDataAge() {
    const lastRefresh = this.storageManager.getData(this.lastRefreshKey);
    if (!lastRefresh) return null;
    
    const now = Date.now();
    return Math.floor((now - lastRefresh) / (1000 * 60 * 60));
  }

  /**
   * Anonymize sensitive data
   * Remove PII but keep structure intact
   */
  anonymizeData(data, type) {
    if (!data || !Array.isArray(data)) return data;
    
    return data.map(item => {
      const anonymized = { ...item };
      
      // Remove or anonymize sensitive fields
      if (anonymized.email) {
        anonymized.email = `demo-${anonymized.id}@example.com`;
      }
      
      if (anonymized.name) {
        anonymized.name = `Demo ${anonymized.name}`;
      }
      
      if (anonymized.phone) {
        anonymized.phone = '555-000-0000';
      }
      
      // Keep all other fields exactly as platform generated
      return anonymized;
    });
  }

  /**
   * Get demo data statistics
   */
  getDemoDataStats() {
    const demoData = this.storageManager.getData(this.demoDataKey);
    if (!demoData) return null;
    
    return {
      userCount: demoData.users ? demoData.users.length : 0,
      projectCount: demoData.projects ? demoData.projects.length : 0,
      taskCount: demoData.tasks ? demoData.tasks.length : 0,
      lastRefresh: this.getDemoDataAge(),
      isStale: this.getDemoDataAge() > 24
    };
  }

  /**
   * Clear demo data
   */
  clearDemoData() {
    this.storageManager.removeData(this.demoDataKey);
    this.storageManager.removeData(this.lastRefreshKey);
    logger.log('üóëÔ∏è Demo data cleared');
  }
}

// Export for use in other modules
// Export as ES module
export default DemoDataManager;
